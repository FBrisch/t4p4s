
# SPDX-License-Identifier: Apache-2.0
# Copyright 2019 Eotvos Lorand University, Budapest, Hungary

# Autogenerated file (from src/hardware_indep/dataplane_key.c.py:), do not modify directly.
# Generator: T4P4S (https://github.com/P4ELTE/t4p4s/)

import compiler_common
import re

def add_code(line, indent_level = 0, lineno = None, file = "src/hardware_indep/dataplane_key.c.py:"):
    global generated_code

    line_ends = {
        "line_comment": "\n",
        "inline_comment": "",
        "no_comment": "\n",
        "no_comment_inline": "",
    }

    sugar_style = compiler_common.file_sugar_style[-1]

    stripped_line = line.strip()
    no_sugar_on_line = stripped_line.startswith('//') or stripped_line.startswith('# ') or stripped_line == ""

    indent = compiler_common.file_indent_str * indent_level
    if 'inline' in compiler_common.file_sugar_style[-1]:
        indent = ''

    sugared = sugar(no_sugar_on_line, file, lineno, sugar_style)
    line_end = line_ends[sugar_style]
    return f'{indent}{stripped_line}{sugared}{line_end}'


def sugar(no_sugar_on_line, file, lineno, sugar_style):
    if True or no_sugar_on_line or file is None or lineno is None:
        return ""

    if sugar_style == 'line_comment':
        return f" // {file}{lineno}"
    if sugar_style == 'inline_comment':
        return f" /* {file}{lineno} */"
    return ""


generated_code += "// Autogenerated file (from src/hardware_indep/dataplane_key.c.py: via hardware_indep/dataplane_key.c.py), do not modify directly.\n"
generated_code += "// Generator: T4P4S (https://github.com/P4ELTE/t4p4s/)\n"
generated_code += "\n"

# SPDX-License-Identifier: Apache-2.0 ## src/hardware_indep/dataplane_key.c.py:2
# Copyright 2016 Eotvos Lorand University, Budapest, Hungary ## src/hardware_indep/dataplane_key.c.py:3

generated_code += add_code("")
from utils.codegen import format_declaration, format_statement, format_expr, format_type, gen_format_type, get_method_call_env ## src/hardware_indep/dataplane_key.c.py:5
from compiler_log_warnings_errors import addError, addWarning ## src/hardware_indep/dataplane_key.c.py:6
from compiler_common import types, generate_var_name, get_hdrfld_name, unique_everseen ## src/hardware_indep/dataplane_key.c.py:7
from hlir16.hlir_utils import align8_16_32 ## src/hardware_indep/dataplane_key.c.py:8

generated_code += add_code("")
generated_code += add_code(" #include \"gen_include.h\"", lineno = 9)
generated_code += add_code(" #include \"dataplane_impl.h\"", lineno = 10)
generated_code += add_code(" #include \"dpdk_lib_byteorder.h\"", lineno = 11)

generated_code += add_code("")
# TODO this is too low level ## src/hardware_indep/dataplane_key.c.py:16

generated_code += add_code("")
generated_code += add_code(" extern int FLD_BYTEOFFSET(header_descriptor_t hdesc, field_instance_e fld);", lineno = 17)

generated_code += add_code("")
generated_code += add_code(" uint8_t* handle_byte_addr(packet_descriptor_t* pd, field_instance_e fld) {", lineno = 19)
generated_code += add_code("     int hdridx = fld_infos[fld].header_instance;", indent_level = 1, lineno = 20)
generated_code += add_code("     header_descriptor_t hdr = pd->headers[hdridx];", indent_level = 1, lineno = 21)
generated_code += add_code("     return (((uint8_t*)hdr.pointer) + (FLD_BYTEOFFSET(hdr, fld)));", indent_level = 1, lineno = 22)
generated_code += add_code(" }", lineno = 23)
generated_code += add_code("", lineno = 24)

generated_code += add_code("")
generated_code += add_code(" bool is_invalid(packet_descriptor_t* pd, header_instance_e hdr, const char* hi_name, const char* fld_name) {", lineno = 26)
generated_code += add_code("     if (unlikely(!is_header_valid(hdr, pd))) {", indent_level = 1, lineno = 27)
generated_code += add_code("         #ifdef T4P4S_DEBUG", indent_level = 2, lineno = 28)
generated_code += add_code("             debug(\" \" T4LIT(!!!!,error) \" \" T4LIT(Lookup on invalid header,error) \" \" T4LIT(%s,header) \".\" T4LIT(%s,field) \", \" T4LIT(it will contain an unspecified value,warning) \"\\n\", hi_name, fld_name);", indent_level = 3, lineno = 29)
generated_code += add_code("         #endif", indent_level = 2, lineno = 30)
generated_code += add_code("         return true;", indent_level = 2, lineno = 31)
generated_code += add_code("     }", indent_level = 1, lineno = 32)
generated_code += add_code("     return false;", indent_level = 1, lineno = 33)
generated_code += add_code(" }", lineno = 34)
generated_code += add_code("", lineno = 35)

generated_code += add_code("")
generated_code += add_code(" uint8_t* get_fld_ptr(packet_descriptor_t* pd, field_instance_e fld) {", lineno = 38)
generated_code += add_code("     header_instance_e hdr = fld_infos[fld].header_instance;", lineno = 39)
generated_code += add_code("     return pd->headers[hdr].pointer + fld_infos[fld].byte_offset;", lineno = 40)
generated_code += add_code(" }", lineno = 41)

generated_code += add_code("")
field_size_print_limit = 12 ## src/hardware_indep/dataplane_key.c.py:44

generated_code += add_code("")
for table in hlir.tables: ## src/hardware_indep/dataplane_key.c.py:46
    if 'key' not in table or table.key_bit_size == 0: ## src/hardware_indep/dataplane_key.c.py:47
        continue ## src/hardware_indep/dataplane_key.c.py:48
    generated_code += add_code(' void table_{}_key(packet_descriptor_t* pd, uint8_t* key KEYTXTPARAMS) {{'.format(table.name), lineno = 49)
    sortedkeys = sorted(table.key.keyElements, key=lambda k: k.match_order) ## src/hardware_indep/dataplane_key.c.py:51
    #TODO variable length fields ## src/hardware_indep/dataplane_key.c.py:52
    #TODO field masks ## src/hardware_indep/dataplane_key.c.py:53
    for key in sortedkeys: ## src/hardware_indep/dataplane_key.c.py:54
        if 'header' in key: ## src/hardware_indep/dataplane_key.c.py:55
            hi_name = "all_metadatas" if key.header.urtype.is_metadata else key.header.name ## src/hardware_indep/dataplane_key.c.py:56
            generated_code += add_code('     if (is_invalid(pd, HDR({}), "{}", "{}"))    return;'.format(hi_name, hi_name, key.field_name), indent_level = 1, lineno = 57)
            fld = key.header.urtype.fields.get(key.field_name) ## src/hardware_indep/dataplane_key.c.py:60
            size = key.size ## src/hardware_indep/dataplane_key.c.py:62
            byte_width = (size+7)//8 ## src/hardware_indep/dataplane_key.c.py:63
            if size <= 32: ## src/hardware_indep/dataplane_key.c.py:64
                padded_byte_width = align8_16_32(size) ## src/hardware_indep/dataplane_key.c.py:65
                generated_code += add_code('     *(uint{}_t*)key = GET32(src_pkt(pd), FLD({},{}));'.format(padded_byte_width, hi_name, key.field_name), indent_level = 1, lineno = 65)
                generated_code += add_code("     #ifdef T4P4S_DEBUG", indent_level = 1, lineno = 67)
                generated_code += add_code('         *key_txt_idx += sprintf(key_txt + *key_txt_idx, T4LIT({},header) "." T4LIT({},field) "/" T4LIT(%db) "=" T4LIT(%d) "=" T4COLOR(T4LIGHT_bytes) "0x",'.format(hi_name, fld.short_name), indent_level = 2, lineno = 68)
                generated_code += add_code('                                 {}, net2t4p4s_{}(*(uint{}_t*)key));'.format(size, padded_byte_width//8, padded_byte_width), indent_level = 2, lineno = 69)
                generated_code += add_code('         *key_txt_idx += dbg_sprint_bytes_limit(key_txt + *key_txt_idx, get_fld_ptr(pd, FLD({},{})), {}, {}, "_");'.format(hi_name, key.field_name, byte_width, field_size_print_limit), indent_level = 2, lineno = 70)
                generated_code += add_code("         *key_txt_idx += sprintf(key_txt + *key_txt_idx, T4COLOR(T4LIGHT_off) \" \");", indent_level = 2, lineno = 71)
                generated_code += add_code("     #endif", indent_level = 1, lineno = 72)
            else: ## src/hardware_indep/dataplane_key.c.py:74
                if size % 8 != 0: ## src/hardware_indep/dataplane_key.c.py:75
                    addWarning("table key computation", f"Field {key.id}/{size}b is longer than 32b and not byte aligned, may cause problems") ## src/hardware_indep/dataplane_key.c.py:76
                generated_code += add_code('     GET_BUF(key, src_pkt(pd), FLD({},{}));'.format(key.header.name, key.field_name), indent_level = 1, lineno = 77)
                generated_code += add_code("     #ifdef T4P4S_DEBUG", indent_level = 1, lineno = 79)
                generated_code += add_code('         *key_txt_idx += sprintf(key_txt + *key_txt_idx, T4LIT({},header) "." T4LIT({},field) "/" T4LIT(%db) "=" T4COLOR(T4LIGHT_bytes), {});'.format(hi_name, fld.short_name, size), indent_level = 2, lineno = 80)
                generated_code += add_code('         *key_txt_idx += dbg_sprint_bytes_limit(key_txt + *key_txt_idx, get_fld_ptr(pd, FLD({},{})), {}, {}, "_");'.format(hi_name, key.field_name, byte_width, field_size_print_limit), indent_level = 2, lineno = 81)
                generated_code += add_code("         *key_txt_idx += sprintf(key_txt + *key_txt_idx, T4COLOR(T4LIGHT_off) \" \");", indent_level = 2, lineno = 82)
                generated_code += add_code("     #endif", indent_level = 1, lineno = 83)
            generated_code += add_code('     key += {};'.format(byte_width), indent_level = 1, lineno = 85)
        else: ## src/hardware_indep/dataplane_key.c.py:87
            ke = key.expression ## src/hardware_indep/dataplane_key.c.py:88
            if ke.node_type == 'MethodCallExpression': ## src/hardware_indep/dataplane_key.c.py:89
                byte_width = (ke.urtype.size + 7) // 8 ## src/hardware_indep/dataplane_key.c.py:90
                mname = ke.method.member ## src/hardware_indep/dataplane_key.c.py:91
                var = generate_var_name(f'mcall_{mname}') ## src/hardware_indep/dataplane_key.c.py:92
                generated_code += add_code('     {} {} = {};'.format(format_type(ke.type), var, format_expr(ke)), indent_level = 1, lineno = 92)
                generated_code += add_code('     memcpy(key, &{}, {});'.format(var, byte_width), indent_level = 1, lineno = 93)
                generated_code += add_code("     #ifdef T4P4S_DEBUG", indent_level = 1, lineno = 95)
                if mname == 'isValid': ## src/hardware_indep/dataplane_key.c.py:97
                    generated_code += add_code('         *key_txt_idx += sprintf(key_txt + *key_txt_idx, "{}() =" T4LIT(%s,bytes) " ", is_header_valid(HDR({}), pd) ? "false" : "true");'.format(mname, hi_name), indent_level = 2, lineno = 97)
                else: ## src/hardware_indep/dataplane_key.c.py:99
                    generated_code += add_code('         *key_txt_idx += sprintf(key_txt + *key_txt_idx, "{}() =" T4COLOR(T4LIGHT_bytes));'.format(mname), indent_level = 2, lineno = 99)
                    generated_code += add_code('         *key_txt_idx += dbg_sprint_bytes_limit(key_txt + *key_txt_idx, get_fld_ptr(pd, FLD({},{})), {}, {}, "_");'.format(hi_name, key.field_name, byte_width, field_size_print_limit), indent_level = 2, lineno = 100)
                    generated_code += add_code("         *key_txt_idx += sprintf(key_txt + *key_txt_idx, T4COLOR(T4LIGHT_off) \" \");", indent_level = 2, lineno = 101)
                generated_code += add_code("     #endif", indent_level = 1, lineno = 102)
            elif key.size <= 32 or key.size % 8 == 0: ## src/hardware_indep/dataplane_key.c.py:104
                if ke.node_type == 'Slice': ## src/hardware_indep/dataplane_key.c.py:105
                    high = ke.e1.value ## src/hardware_indep/dataplane_key.c.py:106
                    low = ke.e2.value ## src/hardware_indep/dataplane_key.c.py:107
                    bit_width = high - low + 1 ## src/hardware_indep/dataplane_key.c.py:108
                    byte_width = (bit_width+7) // 8 ## src/hardware_indep/dataplane_key.c.py:109
                    bit_offset = ke.e0.urtype.size - high - 1 ## src/hardware_indep/dataplane_key.c.py:111
                    byte_offset = (bit_offset+7) // 8 ## src/hardware_indep/dataplane_key.c.py:112
                    is_byte_aligned = bit_width % 8 == 0 ## src/hardware_indep/dataplane_key.c.py:114
                    hdrname, fldname = get_hdrfld_name(ke.e0) ## src/hardware_indep/dataplane_key.c.py:116
                    # TODO this implementation is too low level ## src/hardware_indep/dataplane_key.c.py:118
                    generated_code += add_code('     memcpy(key, handle_byte_addr(pd, FLD({},{})) + {}, {}); // slice: {}.{}[{}:{}]'.format(hdrname, fldname, byte_offset, byte_width, hdrname, fldname, high, low), indent_level = 1, lineno = 118)
                    generated_code += add_code("     #ifdef T4P4S_DEBUG", indent_level = 1, lineno = 120)
                    generated_code += add_code('         *key_txt_idx += sprintf(key_txt + *key_txt_idx, T4LIT({},header) "." T4LIT({},field) "[" T4LIT({}) ":]" T4LIT({}) "=" T4COLOR(T4LIGHT_bytes));'.format(hi_name, fld.short_name, high, low), indent_level = 2, lineno = 121)
                    generated_code += add_code('         *key_txt_idx += dbg_sprint_bytes_limit(key_txt + *key_txt_idx, key, {}, {}, "_");'.format(byte_width, field_size_print_limit), indent_level = 2, lineno = 122)
                    generated_code += add_code("         *key_txt_idx += sprintf(key_txt + *key_txt_idx, T4COLOR(T4LIGHT_off) \" \");", indent_level = 2, lineno = 123)
                    generated_code += add_code("     #endif", indent_level = 1, lineno = 124)
                    if not is_byte_aligned: ## src/hardware_indep/dataplane_key.c.py:127
                        in_byte_offset = bit_offset - byte_offset * 8 ## src/hardware_indep/dataplane_key.c.py:128
                        # TODO implement this case properly ## src/hardware_indep/dataplane_key.c.py:129
                        pass ## src/hardware_indep/dataplane_key.c.py:130
                else: ## src/hardware_indep/dataplane_key.c.py:131
                    # fld is a control local ## src/hardware_indep/dataplane_key.c.py:132
                    byte_width = (key.size+7)//8 ## src/hardware_indep/dataplane_key.c.py:133
                    locname = ke.path.name ## src/hardware_indep/dataplane_key.c.py:134
                    short_name = table.control.controlLocals.get(locname, 'Declaration_Variable').short_name ## src/hardware_indep/dataplane_key.c.py:135
                    generated_code += add_code('     memcpy(key, &((control_locals_{}_t*) pd->control_locals)->{}, {});'.format(table.control.name, locname, byte_width), indent_level = 1, lineno = 135)
                    generated_code += add_code("     #ifdef T4P4S_DEBUG", indent_level = 1, lineno = 137)
                    generated_code += add_code('         *key_txt_idx += sprintf(key_txt + *key_txt_idx, T4LIT({},field) "/" T4LIT(%db) "=" T4COLOR(T4LIGHT_bytes), {});'.format(short_name, key.size), indent_level = 2, lineno = 138)
                    generated_code += add_code('         *key_txt_idx += dbg_sprint_bytes_limit(key_txt + *key_txt_idx, key, {}, {}, "_");'.format(byte_width, field_size_print_limit), indent_level = 2, lineno = 139)
                    generated_code += add_code("         *key_txt_idx += sprintf(key_txt + *key_txt_idx, T4COLOR(T4LIGHT_off) \" \");", indent_level = 2, lineno = 140)
                    generated_code += add_code("     #endif", indent_level = 1, lineno = 141)
            else: ## src/hardware_indep/dataplane_key.c.py:143
                addWarning("table key computation", f"Skipping unsupported key component {ke.path.name} ({key.size} bits): it is over 32 bits long and not byte aligned") ## src/hardware_indep/dataplane_key.c.py:144
                continue ## src/hardware_indep/dataplane_key.c.py:145
            generated_code += add_code('     key += {};'.format(byte_width), indent_level = 1, lineno = 146)
        generated_code += add_code("", indent_level = 1, lineno = 147)
    generated_code += add_code(" }", lineno = 148)
    generated_code += add_code("", lineno = 149)
