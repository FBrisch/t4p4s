// Autogenerated file (from src/hardware_indep/hdr_fld_sprintf.c.py: via hardware_indep/hdr_fld_sprintf.c.py), do not modify directly.
// Generator: T4P4S (https://github.com/P4ELTE/t4p4s/)

#include "dpdk_lib.h"
#include "util_packet.h"
#include "gen_include.h"
#include "hdr_fld.h"
#include "hdr_fld_sprintf.h"

char* sprintf_hdr_general(char* out, int field_count, uint32_t vals[], uint8_t* ptrs[], int offsets[], int sizes[], int vw_sizes[], const char*const fld_short_names[]) {
    #ifdef T4P4S_DEBUG
        for (int idx = 0; idx < field_count; ++idx) {
            const char* sep_space = idx != field_count - 1 ? " " : "";
            if (sizes[idx] <= 32 && vw_sizes[idx] == NO_VW_FIELD_PRESENT) {
                bool is_aligned = sizes[idx] % 8 == 0 && offsets[idx] % 8 == 0;
                bool fld_is_too_large = sizes[idx] < 32 && vals[idx] > 1 << sizes[idx];
                const char* fld_is_too_large_txt = fld_is_too_large ? T4LIT(!too large!,error) : "";
                if (vals[idx] > 9) {
                    const char* fmt8 = "." T4LIT(%s,field) "/" T4LIT(%d) "%s=%s" T4LIT(%d) "=0x" T4LIT(%02x,bytes) "%s";
                    const char* fmt16 = "." T4LIT(%s,field) "/" T4LIT(%d) "%s=%s" T4LIT(%d) "=0x" T4LIT(%04x,bytes) "%s";
                    const char* fmt32 = "." T4LIT(%s,field) "/" T4LIT(%d) "%s=%s" T4LIT(%d) "=0x" T4LIT(%08x,bytes) "%s";
                    out += sprintf(out, sizes[idx] > 16 ? fmt32 : sizes[idx] > 8 ? fmt16 : fmt8,
                    fld_short_names[idx],
                    sizes[idx] / (is_aligned ? 8 : 1), is_aligned ? "B" : "b",
                    fld_is_too_large_txt, vals[idx], vals[idx], sep_space);
                    } else {
                    out += sprintf(out, "." T4LIT(%s,field) "/" T4LIT(%d) "%s=%s" T4LIT(%d) "%s",
                    fld_short_names[idx],
                    sizes[idx] / (is_aligned ? 8 : 1), is_aligned ? "B" : "b",
                    fld_is_too_large_txt, vals[idx], sep_space);
                }
                } else {
                bool is_vw = vw_sizes[idx] != NO_VW_FIELD_PRESENT;
                int size = is_vw ? vw_sizes[idx] : sizes[idx];
                out += sprintf(out, "." T4LIT(%s,field) "/%s" T4LIT(%d) "%s=" T4COLOR(T4LIGHT_bytes),
                fld_short_names[idx],
                is_vw ? "vw" : "", size / (size % 8 == 0 ? 8 : 1), size % 8 == 0 ? "B" : "b");
                out += dbg_sprint_bytes_limit(out, ptrs[idx], size/8, 12, "_");
                out += sprintf(out, T4COLOR(T4LIGHT_off) "%s", sep_space);
            }
        }
    #endif
    return out;
}

const char* detailed_sprintf_hdr_ethernet(char* out, packet_descriptor_t* pd, header_descriptor_t* hdr) {
    uint32_t vals[3];
    uint8_t* ptrs[3];
    int offsets[3] = { 0, 48, 96 };
    int sizes[3] = { 48, 48, 16 };
    int vw_sizes[3] = { NO_VW_FIELD_PRESENT, NO_VW_FIELD_PRESENT, NO_VW_FIELD_PRESENT };
    const char*const fld_short_names[3] = { "dstAddr", "srcAddr", "etherType" };
    ptrs[0] = hdr->pointer + fld_infos[FLD(ethernet,dstAddr)].byte_offset;  // ethernet.dstAddr/6B
    ptrs[1] = hdr->pointer + fld_infos[FLD(ethernet,srcAddr)].byte_offset;  // ethernet.srcAddr/6B
    vals[2] = GET32(src_pkt(pd), FLD(ethernet, etherType));  // ethernet.etherType/16b
    return sprintf_hdr_general(out, 3, vals, ptrs, offsets, sizes, vw_sizes, fld_short_names);
}

const char* detailed_sprintf_hdr_ipv4(char* out, packet_descriptor_t* pd, header_descriptor_t* hdr) {
    uint32_t vals[10];
    uint8_t* ptrs[10];
    int offsets[10] = { 0, 8, 16, 32, 48, 64, 72, 80, 96, 128 };
    int sizes[10] = { 8, 8, 16, 16, 16, 8, 8, 16, 32, 32 };
    int vw_sizes[10] = { NO_VW_FIELD_PRESENT, NO_VW_FIELD_PRESENT, NO_VW_FIELD_PRESENT, NO_VW_FIELD_PRESENT, NO_VW_FIELD_PRESENT, NO_VW_FIELD_PRESENT, NO_VW_FIELD_PRESENT, NO_VW_FIELD_PRESENT, NO_VW_FIELD_PRESENT, NO_VW_FIELD_PRESENT };
    const char*const fld_short_names[10] = { "versionIhl", "diffserv", "totalLen", "identification", "fragOffset", "ttl", "protocol", "hdrChecksum", "srcAddr", "dstAddr" };
    vals[0] = GET32(src_pkt(pd), FLD(ipv4, versionIhl));  // ipv4.versionIhl/8b
    vals[1] = GET32(src_pkt(pd), FLD(ipv4, diffserv));  // ipv4.diffserv/8b
    vals[2] = GET32(src_pkt(pd), FLD(ipv4, totalLen));  // ipv4.totalLen/16b
    vals[3] = GET32(src_pkt(pd), FLD(ipv4, identification));  // ipv4.identification/16b
    vals[4] = GET32(src_pkt(pd), FLD(ipv4, fragOffset));  // ipv4.fragOffset/16b
    vals[5] = GET32(src_pkt(pd), FLD(ipv4, ttl));  // ipv4.ttl/8b
    vals[6] = GET32(src_pkt(pd), FLD(ipv4, protocol));  // ipv4.protocol/8b
    vals[7] = GET32(src_pkt(pd), FLD(ipv4, hdrChecksum));  // ipv4.hdrChecksum/16b
    vals[8] = GET32(src_pkt(pd), FLD(ipv4, srcAddr));  // ipv4.srcAddr/32b
    vals[9] = GET32(src_pkt(pd), FLD(ipv4, dstAddr));  // ipv4.dstAddr/32b
    return sprintf_hdr_general(out, 10, vals, ptrs, offsets, sizes, vw_sizes, fld_short_names);
}

const char* detailed_sprintf_hdr_arp(char* out, packet_descriptor_t* pd, header_descriptor_t* hdr) {
    uint32_t vals[9];
    uint8_t* ptrs[9];
    int offsets[9] = { 0, 16, 32, 40, 48, 64, 112, 144, 192 };
    int sizes[9] = { 16, 16, 8, 8, 16, 48, 32, 48, 32 };
    int vw_sizes[9] = { NO_VW_FIELD_PRESENT, NO_VW_FIELD_PRESENT, NO_VW_FIELD_PRESENT, NO_VW_FIELD_PRESENT, NO_VW_FIELD_PRESENT, NO_VW_FIELD_PRESENT, NO_VW_FIELD_PRESENT, NO_VW_FIELD_PRESENT, NO_VW_FIELD_PRESENT };
    const char*const fld_short_names[9] = { "hardware_type", "protocol_type", "HLEN", "PLEN", "OPER", "sender_ha", "sender_ip", "target_ha", "target_ip" };
    vals[0] = GET32(src_pkt(pd), FLD(arp, hardware_type));  // arp.hardware_type/16b
    vals[1] = GET32(src_pkt(pd), FLD(arp, protocol_type));  // arp.protocol_type/16b
    vals[2] = GET32(src_pkt(pd), FLD(arp, HLEN));  // arp.HLEN/8b
    vals[3] = GET32(src_pkt(pd), FLD(arp, PLEN));  // arp.PLEN/8b
    vals[4] = GET32(src_pkt(pd), FLD(arp, OPER));  // arp.OPER/16b
    ptrs[5] = hdr->pointer + fld_infos[FLD(arp,sender_ha)].byte_offset;  // arp.sender_ha/6B
    vals[6] = GET32(src_pkt(pd), FLD(arp, sender_ip));  // arp.sender_ip/32b
    ptrs[7] = hdr->pointer + fld_infos[FLD(arp,target_ha)].byte_offset;  // arp.target_ha/6B
    vals[8] = GET32(src_pkt(pd), FLD(arp, target_ip));  // arp.target_ip/32b
    return sprintf_hdr_general(out, 9, vals, ptrs, offsets, sizes, vw_sizes, fld_short_names);
}

const char* sprintf_hdr(char* out, packet_descriptor_t* pd, header_descriptor_t* hdr) {
    #ifdef T4P4S_DEBUG
        const char* name = hdr_infos[hdr->type].name;
        if (!strcmp("ethernet", name))    return detailed_sprintf_hdr_ethernet(out, pd, hdr);
        if (!strcmp("ipv4", name))    return detailed_sprintf_hdr_ipv4(out, pd, hdr);
        if (!strcmp("arp", name))    return detailed_sprintf_hdr_arp(out, pd, hdr);
    #endif
    return NULL; // should never happen
}

