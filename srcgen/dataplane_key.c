// Autogenerated file (from src/hardware_indep/dataplane_key.c.py: via hardware_indep/dataplane_key.c.py), do not modify directly.
// Generator: T4P4S (https://github.com/P4ELTE/t4p4s/)

#include "gen_include.h"
#include "dataplane_impl.h"
#include "dpdk_lib_byteorder.h"

extern int FLD_BYTEOFFSET(header_descriptor_t hdesc, field_instance_e fld);

uint8_t* handle_byte_addr(packet_descriptor_t* pd, field_instance_e fld) {
    int hdridx = fld_infos[fld].header_instance;
    header_descriptor_t hdr = pd->headers[hdridx];
    return (((uint8_t*)hdr.pointer) + (FLD_BYTEOFFSET(hdr, fld)));
}

bool is_invalid(packet_descriptor_t* pd, header_instance_e hdr, const char* hi_name, const char* fld_name) {
    if (unlikely(!is_header_valid(hdr, pd))) {
        #ifdef T4P4S_DEBUG
            debug(" " T4LIT(!!!!,error) " " T4LIT(Lookup on invalid header,error) " " T4LIT(%s,header) "." T4LIT(%s,field) ", " T4LIT(it will contain an unspecified value,warning) "\n", hi_name, fld_name);
        #endif
        return true;
    }
    return false;
}

uint8_t* get_fld_ptr(packet_descriptor_t* pd, field_instance_e fld) {
header_instance_e hdr = fld_infos[fld].header_instance;
return pd->headers[hdr].pointer + fld_infos[fld].byte_offset;
}

void table_ipv4_lpm_0_key(packet_descriptor_t* pd, uint8_t* key KEYTXTPARAMS) {
    if (is_invalid(pd, HDR(ipv4), "ipv4", "dstAddr"))    return;
    *(uint32_t*)key = GET32(src_pkt(pd), FLD(ipv4,dstAddr));
    #ifdef T4P4S_DEBUG
        *key_txt_idx += sprintf(key_txt + *key_txt_idx, T4LIT(ipv4,header) "." T4LIT(dstAddr,field) "/" T4LIT(%db) "=" T4LIT(%d) "=" T4COLOR(T4LIGHT_bytes) "0x",
        32, net2t4p4s_4(*(uint32_t*)key));
        *key_txt_idx += dbg_sprint_bytes_limit(key_txt + *key_txt_idx, get_fld_ptr(pd, FLD(ipv4,dstAddr)), 4, 12, "_");
        *key_txt_idx += sprintf(key_txt + *key_txt_idx, T4COLOR(T4LIGHT_off) " ");
    #endif
    key += 4;
    
}

void table_nexthops_0_key(packet_descriptor_t* pd, uint8_t* key KEYTXTPARAMS) {
    if (is_invalid(pd, HDR(all_metadatas), "all_metadatas", "_routing_metadata_nhgroup0"))    return;
    *(uint32_t*)key = GET32(src_pkt(pd), FLD(all_metadatas,_routing_metadata_nhgroup0));
    #ifdef T4P4S_DEBUG
        *key_txt_idx += sprintf(key_txt + *key_txt_idx, T4LIT(all_metadatas,header) "." T4LIT(_routing_metadata_nhgroup0,field) "/" T4LIT(%db) "=" T4LIT(%d) "=" T4COLOR(T4LIGHT_bytes) "0x",
        32, net2t4p4s_4(*(uint32_t*)key));
        *key_txt_idx += dbg_sprint_bytes_limit(key_txt + *key_txt_idx, get_fld_ptr(pd, FLD(all_metadatas,_routing_metadata_nhgroup0)), 4, 12, "_");
        *key_txt_idx += sprintf(key_txt + *key_txt_idx, T4COLOR(T4LIGHT_off) " ");
    #endif
    key += 4;
    
}

