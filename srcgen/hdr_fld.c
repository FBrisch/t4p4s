// Autogenerated file (from src/hardware_indep/hdr_fld.c.py: via hardware_indep/hdr_fld.c.py), do not modify directly.
// Generator: T4P4S (https://github.com/P4ELTE/t4p4s/)

#include "dpdk_lib.h"
#include "util_packet.h"
#include "gen_include.h"
#include "hdr_fld.h"
#include "hdr_fld_sprintf.h"

const char*const header_instance_names[HEADER_COUNT] = {
    "ethernet",
    "ipv4",
    "arp",
};

const char*const field_names[FIELD_COUNT] = {
    // ethernet
    "dstAddr", // ethernet.dstAddr
    "srcAddr", // ethernet.srcAddr
    "etherType", // ethernet.etherType
    // ipv4
    "versionIhl", // ipv4.versionIhl
    "diffserv", // ipv4.diffserv
    "totalLen", // ipv4.totalLen
    "identification", // ipv4.identification
    "fragOffset", // ipv4.fragOffset
    "ttl", // ipv4.ttl
    "protocol", // ipv4.protocol
    "hdrChecksum", // ipv4.hdrChecksum
    "srcAddr", // ipv4.srcAddr
    "dstAddr", // ipv4.dstAddr
    // arp
    "hardware_type", // arp.hardware_type
    "protocol_type", // arp.protocol_type
    "HLEN", // arp.HLEN
    "PLEN", // arp.PLEN
    "OPER", // arp.OPER
    "sender_ha", // arp.sender_ha
    "sender_ip", // arp.sender_ip
    "target_ha", // arp.target_ha
    "target_ip", // arp.target_ip
};

const hdr_info_t hdr_infos[HEADER_COUNT] = {
    // header ethernet
    {
        .idx = 0,
        .name = "ethernet",
        .byte_width = 14, // 112 bits, 14.0 bytes
        .byte_offset = 0,
        .is_metadata = false,
        .var_width_field = NO_VW_FIELD_PRESENT,
        .var_width_size  = 0,
        .first_fld = FLD(ethernet,dstAddr),
        .last_fld = FLD(ethernet,etherType),
    },
    
    // header ipv4
    {
        .idx = 1,
        .name = "ipv4",
        .byte_width = 20, // 160 bits, 20.0 bytes
        .byte_offset = 0+14,
        .is_metadata = false,
        .var_width_field = NO_VW_FIELD_PRESENT,
        .var_width_size  = 0,
        .first_fld = FLD(ipv4,versionIhl),
        .last_fld = FLD(ipv4,dstAddr),
    },
    
    // header arp
    {
        .idx = 2,
        .name = "arp",
        .byte_width = 28, // 224 bits, 28.0 bytes
        .byte_offset = 0+14+20,
        .is_metadata = false,
        .var_width_field = NO_VW_FIELD_PRESENT,
        .var_width_size  = 0,
        .first_fld = FLD(arp,hardware_type),
        .last_fld = FLD(arp,target_ip),
    },
    
};

const fld_info_t fld_infos[FIELD_COUNT] = {
    // field ethernet.dstAddr
    {
        .instance = FLD(ethernet, dstAddr),
        .header_instance = HDR(ethernet),
        .size = 48,
        .byte_width = to_bytes(48),
        .bit_offset = 0 % 8,
        .byte_offset = 0 / 8,
        .is_vw = false,
        .name = "dstAddr",
        .short_name = "dstAddr",
        // .mask ignored: 48b field is restricted to be byte aligned (over 32b)
    },
    
    // field ethernet.srcAddr
    {
        .instance = FLD(ethernet, srcAddr),
        .header_instance = HDR(ethernet),
        .size = 48,
        .byte_width = to_bytes(48),
        .bit_offset = 48 % 8,
        .byte_offset = 48 / 8,
        .is_vw = false,
        .name = "srcAddr",
        .short_name = "srcAddr",
        // .mask ignored: 48b field is restricted to be byte aligned (over 32b)
    },
    
    // field ethernet.etherType
    {
        .instance = FLD(ethernet, etherType),
        .header_instance = HDR(ethernet),
        .size = 16,
        .byte_width = to_bytes(16),
        .bit_offset = 96 % 8,
        .byte_offset = 96 / 8,
        .is_vw = false,
        .name = "etherType",
        .short_name = "etherType",
        .mask = 0xffff0000, // 16b at offset 12B+0b: 0b11111111_11111111
    },
    
    // field ipv4.versionIhl
    {
        .instance = FLD(ipv4, versionIhl),
        .header_instance = HDR(ipv4),
        .size = 8,
        .byte_width = to_bytes(8),
        .bit_offset = 0 % 8,
        .byte_offset = 0 / 8,
        .is_vw = false,
        .name = "versionIhl",
        .short_name = "versionIhl",
        .mask = 0xff000000, // 8b at offset 0B+0b: 0b11111111
    },
    
    // field ipv4.diffserv
    {
        .instance = FLD(ipv4, diffserv),
        .header_instance = HDR(ipv4),
        .size = 8,
        .byte_width = to_bytes(8),
        .bit_offset = 8 % 8,
        .byte_offset = 8 / 8,
        .is_vw = false,
        .name = "diffserv",
        .short_name = "diffserv",
        .mask = 0xff000000, // 8b at offset 1B+0b: 0b11111111
    },
    
    // field ipv4.totalLen
    {
        .instance = FLD(ipv4, totalLen),
        .header_instance = HDR(ipv4),
        .size = 16,
        .byte_width = to_bytes(16),
        .bit_offset = 16 % 8,
        .byte_offset = 16 / 8,
        .is_vw = false,
        .name = "totalLen",
        .short_name = "totalLen",
        .mask = 0xffff0000, // 16b at offset 2B+0b: 0b11111111_11111111
    },
    
    // field ipv4.identification
    {
        .instance = FLD(ipv4, identification),
        .header_instance = HDR(ipv4),
        .size = 16,
        .byte_width = to_bytes(16),
        .bit_offset = 32 % 8,
        .byte_offset = 32 / 8,
        .is_vw = false,
        .name = "identification",
        .short_name = "identification",
        .mask = 0xffff0000, // 16b at offset 4B+0b: 0b11111111_11111111
    },
    
    // field ipv4.fragOffset
    {
        .instance = FLD(ipv4, fragOffset),
        .header_instance = HDR(ipv4),
        .size = 16,
        .byte_width = to_bytes(16),
        .bit_offset = 48 % 8,
        .byte_offset = 48 / 8,
        .is_vw = false,
        .name = "fragOffset",
        .short_name = "fragOffset",
        .mask = 0xffff0000, // 16b at offset 6B+0b: 0b11111111_11111111
    },
    
    // field ipv4.ttl
    {
        .instance = FLD(ipv4, ttl),
        .header_instance = HDR(ipv4),
        .size = 8,
        .byte_width = to_bytes(8),
        .bit_offset = 64 % 8,
        .byte_offset = 64 / 8,
        .is_vw = false,
        .name = "ttl",
        .short_name = "ttl",
        .mask = 0xff000000, // 8b at offset 8B+0b: 0b11111111
    },
    
    // field ipv4.protocol
    {
        .instance = FLD(ipv4, protocol),
        .header_instance = HDR(ipv4),
        .size = 8,
        .byte_width = to_bytes(8),
        .bit_offset = 72 % 8,
        .byte_offset = 72 / 8,
        .is_vw = false,
        .name = "protocol",
        .short_name = "protocol",
        .mask = 0xff000000, // 8b at offset 9B+0b: 0b11111111
    },
    
    // field ipv4.hdrChecksum
    {
        .instance = FLD(ipv4, hdrChecksum),
        .header_instance = HDR(ipv4),
        .size = 16,
        .byte_width = to_bytes(16),
        .bit_offset = 80 % 8,
        .byte_offset = 80 / 8,
        .is_vw = false,
        .name = "hdrChecksum",
        .short_name = "hdrChecksum",
        .mask = 0xffff0000, // 16b at offset 10B+0b: 0b11111111_11111111
    },
    
    // field ipv4.srcAddr
    {
        .instance = FLD(ipv4, srcAddr),
        .header_instance = HDR(ipv4),
        .size = 32,
        .byte_width = to_bytes(32),
        .bit_offset = 96 % 8,
        .byte_offset = 96 / 8,
        .is_vw = false,
        .name = "srcAddr",
        .short_name = "srcAddr",
        .mask = 0xffffffff, // 32b at offset 12B+0b: 0b11111111_11111111_11111111_11111111
    },
    
    // field ipv4.dstAddr
    {
        .instance = FLD(ipv4, dstAddr),
        .header_instance = HDR(ipv4),
        .size = 32,
        .byte_width = to_bytes(32),
        .bit_offset = 128 % 8,
        .byte_offset = 128 / 8,
        .is_vw = false,
        .name = "dstAddr",
        .short_name = "dstAddr",
        .mask = 0xffffffff, // 32b at offset 16B+0b: 0b11111111_11111111_11111111_11111111
    },
    
    // field arp.hardware_type
    {
        .instance = FLD(arp, hardware_type),
        .header_instance = HDR(arp),
        .size = 16,
        .byte_width = to_bytes(16),
        .bit_offset = 0 % 8,
        .byte_offset = 0 / 8,
        .is_vw = false,
        .name = "hardware_type",
        .short_name = "hardware_type",
        .mask = 0xffff0000, // 16b at offset 0B+0b: 0b11111111_11111111
    },
    
    // field arp.protocol_type
    {
        .instance = FLD(arp, protocol_type),
        .header_instance = HDR(arp),
        .size = 16,
        .byte_width = to_bytes(16),
        .bit_offset = 16 % 8,
        .byte_offset = 16 / 8,
        .is_vw = false,
        .name = "protocol_type",
        .short_name = "protocol_type",
        .mask = 0xffff0000, // 16b at offset 2B+0b: 0b11111111_11111111
    },
    
    // field arp.HLEN
    {
        .instance = FLD(arp, HLEN),
        .header_instance = HDR(arp),
        .size = 8,
        .byte_width = to_bytes(8),
        .bit_offset = 32 % 8,
        .byte_offset = 32 / 8,
        .is_vw = false,
        .name = "HLEN",
        .short_name = "HLEN",
        .mask = 0xff000000, // 8b at offset 4B+0b: 0b11111111
    },
    
    // field arp.PLEN
    {
        .instance = FLD(arp, PLEN),
        .header_instance = HDR(arp),
        .size = 8,
        .byte_width = to_bytes(8),
        .bit_offset = 40 % 8,
        .byte_offset = 40 / 8,
        .is_vw = false,
        .name = "PLEN",
        .short_name = "PLEN",
        .mask = 0xff000000, // 8b at offset 5B+0b: 0b11111111
    },
    
    // field arp.OPER
    {
        .instance = FLD(arp, OPER),
        .header_instance = HDR(arp),
        .size = 16,
        .byte_width = to_bytes(16),
        .bit_offset = 48 % 8,
        .byte_offset = 48 / 8,
        .is_vw = false,
        .name = "OPER",
        .short_name = "OPER",
        .mask = 0xffff0000, // 16b at offset 6B+0b: 0b11111111_11111111
    },
    
    // field arp.sender_ha
    {
        .instance = FLD(arp, sender_ha),
        .header_instance = HDR(arp),
        .size = 48,
        .byte_width = to_bytes(48),
        .bit_offset = 64 % 8,
        .byte_offset = 64 / 8,
        .is_vw = false,
        .name = "sender_ha",
        .short_name = "sender_ha",
        // .mask ignored: 48b field is restricted to be byte aligned (over 32b)
    },
    
    // field arp.sender_ip
    {
        .instance = FLD(arp, sender_ip),
        .header_instance = HDR(arp),
        .size = 32,
        .byte_width = to_bytes(32),
        .bit_offset = 112 % 8,
        .byte_offset = 112 / 8,
        .is_vw = false,
        .name = "sender_ip",
        .short_name = "sender_ip",
        .mask = 0xffffffff, // 32b at offset 14B+0b: 0b11111111_11111111_11111111_11111111
    },
    
    // field arp.target_ha
    {
        .instance = FLD(arp, target_ha),
        .header_instance = HDR(arp),
        .size = 48,
        .byte_width = to_bytes(48),
        .bit_offset = 144 % 8,
        .byte_offset = 144 / 8,
        .is_vw = false,
        .name = "target_ha",
        .short_name = "target_ha",
        // .mask ignored: 48b field is restricted to be byte aligned (over 32b)
    },
    
    // field arp.target_ip
    {
        .instance = FLD(arp, target_ip),
        .header_instance = HDR(arp),
        .size = 32,
        .byte_width = to_bytes(32),
        .bit_offset = 192 % 8,
        .byte_offset = 192 / 8,
        .is_vw = false,
        .name = "target_ip",
        .short_name = "target_ip",
        .mask = 0xffffffff, // 32b at offset 24B+0b: 0b11111111_11111111_11111111_11111111
    },
    
};

const stk_info_t stk_infos[STACK_COUNT] = {
};

int get_fld_vw_size(field_instance_e fld, packet_descriptor_t* pd) {
    header_instance_e hdr = fld_infos[fld].header_instance;
    return pd->headers[hdr].vw_size;
}

