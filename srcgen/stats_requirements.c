// Autogenerated file (from src/hardware_indep/stats_requirements.c.py: via hardware_indep/stats_requirements.c.py), do not modify directly.
// Generator: T4P4S (https://github.com/P4ELTE/t4p4s/)

// SPDX-License-Identifier: Apache-2.0
// Copyright 2021 Eotvos Lorand University, Budapest, Hungary

#include <string.h>

#include "common.h"
#include "dpdk_lib.h"

#ifndef T4P4S_STATS
    #else
    
    extern t4p4s_stats_t t4p4s_stats_per_packet;
    
    
    typedef enum {
        reqcond_apply,
        reqcond_hit,
        reqcond_miss,
        reqcond_cond,
        reqcond_run,
        reqcond_parse,
        reqcond_NONE,
        reqcond_ERROR,
    } reqcond_e;
    
    
    reqcond_e get_reqcond(const char* name) {
        if (!strcmp("apply", name))    return reqcond_apply;
        if (!strcmp("hit", name))    return reqcond_hit;
        if (!strcmp("miss", name))    return reqcond_miss;
        if (!strcmp("cond", name))    return reqcond_cond;
        if (!strcmp("run", name))    return reqcond_run;
        if (!strcmp("parse", name))    return reqcond_parse;
        if (!strcmp("NONE", name))    return reqcond_NONE;
        if (!strcmp("ERROR", name))    return reqcond_ERROR;
        return reqcond_ERROR;
    };
    
    
    const char* get_reqcond_txt(reqcond_e reqcond) {
        if (reqcond_apply == reqcond)    return "apply";
        if (reqcond_hit == reqcond)    return "hit";
        if (reqcond_miss == reqcond)    return "miss";
        if (reqcond_cond == reqcond)    return "cond";
        if (reqcond_run == reqcond)    return "run";
        if (reqcond_parse == reqcond)    return "parse";
        if (reqcond_NONE == reqcond)    return "NONE";
        if (reqcond_ERROR == reqcond)    return "ERROR";
        return "unreachable code";
    };
    
    
    #define MAX_PART_COUNT 128
    
    
    const char*const prefix_skip_char(const char*const txt, char c) {
        const char* ptr = txt;
        while (*ptr == c)  ++ptr;
        return ptr;
    }
    
    
    int split(char* parts[MAX_PART_COUNT], const char* reqs, const char* separator) {
        int count = 0;
        char* tmp = strdup(reqs);
        while ( (parts[count] = strsep(&tmp,separator)) != NULL )  ++count;
        free(tmp);
        return count;
    }
    
    
    bool check_table_name(const char*const table_name) {
        if (!strcmp("ipv4_lpm", table_name))    return true;
        if (!strcmp("nexthops", table_name))    return true;
        return false;
    }
    
    
    bool check_table_requirement(const char*const table_name, reqcond_e reqcond, bool on) {
        t4p4s_stats_t stat = t4p4s_stats_per_packet;
        if (!strcmp("ipv4_lpm", table_name) && reqcond == reqcond_apply && (on == stat.T4STAT(table,apply,ipv4_lpm_0)))   return true;
        if (!strcmp("ipv4_lpm", table_name) && reqcond == reqcond_hit && (on == stat.T4STAT(table,hit,ipv4_lpm_0)))   return true;
        if (!strcmp("ipv4_lpm", table_name) && reqcond == reqcond_miss && (on == stat.T4STAT(table,miss,ipv4_lpm_0)))   return true;
        if (!strcmp("nexthops", table_name) && reqcond == reqcond_apply && (on == stat.T4STAT(table,apply,nexthops_0)))   return true;
        if (!strcmp("nexthops", table_name) && reqcond == reqcond_hit && (on == stat.T4STAT(table,hit,nexthops_0)))   return true;
        if (!strcmp("nexthops", table_name) && reqcond == reqcond_miss && (on == stat.T4STAT(table,miss,nexthops_0)))   return true;
        return false;
    }
    
    
    bool check_action_requirement(const char*const table_name, reqcond_e reqcond, bool on) {
        return false;
    }
    
    
    bool check_parser_requirement(const char*const table_name, reqcond_e reqcond, bool on) {
        return false;
    }
    
    
    bool check_cond(const char*const cond) {
        const char*const ltrimmed_cond = prefix_skip_char(cond, ' ');
        bool on = true;
        
        bool result = true;
        reqcond_e reqcond = reqcond_NONE;
        char* parts[MAX_PART_COUNT];
        int part_count = split(parts, cond, " ");
        for (int i = 0; i < part_count; ++i) {
        if (strlen(parts[i]) == 0)    continue;
        if (!strcmp("apply", parts[i])) {
            if (reqcond != reqcond_NONE) {
                debug("    " T4LIT(!,warning) " More than one requirement (" T4LIT(apply,warning) " and " T4LIT(%s,warning) ") found in condition " T4LIT(%s,warning) "\n",
                parts[i], ltrimmed_cond);
                result = false;
                goto free_mem; // breaking out of outermost loop
            }
            reqcond = get_reqcond(parts[i]);
            continue;
        }
        if (!strcmp("hit", parts[i])) {
            if (reqcond != reqcond_NONE) {
                debug("    " T4LIT(!,warning) " More than one requirement (" T4LIT(hit,warning) " and " T4LIT(%s,warning) ") found in condition " T4LIT(%s,warning) "\n",
                parts[i], ltrimmed_cond);
                result = false;
                goto free_mem; // breaking out of outermost loop
            }
            reqcond = get_reqcond(parts[i]);
            continue;
        }
        if (!strcmp("miss", parts[i])) {
            if (reqcond != reqcond_NONE) {
                debug("    " T4LIT(!,warning) " More than one requirement (" T4LIT(miss,warning) " and " T4LIT(%s,warning) ") found in condition " T4LIT(%s,warning) "\n",
                parts[i], ltrimmed_cond);
                result = false;
                goto free_mem; // breaking out of outermost loop
            }
            reqcond = get_reqcond(parts[i]);
            continue;
        }
        if (!strcmp("cond", parts[i])) {
            if (reqcond != reqcond_NONE) {
                debug("    " T4LIT(!,warning) " More than one requirement (" T4LIT(cond,warning) " and " T4LIT(%s,warning) ") found in condition " T4LIT(%s,warning) "\n",
                parts[i], ltrimmed_cond);
                result = false;
                goto free_mem; // breaking out of outermost loop
            }
            reqcond = get_reqcond(parts[i]);
            continue;
        }
        if (!strcmp("run", parts[i])) {
            if (reqcond != reqcond_NONE) {
                debug("    " T4LIT(!,warning) " More than one requirement (" T4LIT(run,warning) " and " T4LIT(%s,warning) ") found in condition " T4LIT(%s,warning) "\n",
                parts[i], ltrimmed_cond);
                result = false;
                goto free_mem; // breaking out of outermost loop
            }
            reqcond = get_reqcond(parts[i]);
            continue;
        }
        if (!strcmp("parse", parts[i])) {
            if (reqcond != reqcond_NONE) {
                debug("    " T4LIT(!,warning) " More than one requirement (" T4LIT(parse,warning) " and " T4LIT(%s,warning) ") found in condition " T4LIT(%s,warning) "\n",
                parts[i], ltrimmed_cond);
                result = false;
                goto free_mem; // breaking out of outermost loop
            }
            reqcond = get_reqcond(parts[i]);
            continue;
        }
        if (!strcmp("NONE", parts[i])) {
            if (reqcond != reqcond_NONE) {
                debug("    " T4LIT(!,warning) " More than one requirement (" T4LIT(NONE,warning) " and " T4LIT(%s,warning) ") found in condition " T4LIT(%s,warning) "\n",
                parts[i], ltrimmed_cond);
                result = false;
                goto free_mem; // breaking out of outermost loop
            }
            reqcond = get_reqcond(parts[i]);
            continue;
        }
        if (!strcmp("ERROR", parts[i])) {
            if (reqcond != reqcond_NONE) {
                debug("    " T4LIT(!,warning) " More than one requirement (" T4LIT(ERROR,warning) " and " T4LIT(%s,warning) ") found in condition " T4LIT(%s,warning) "\n",
                parts[i], ltrimmed_cond);
                result = false;
                goto free_mem; // breaking out of outermost loop
            }
            reqcond = get_reqcond(parts[i]);
            continue;
        }
        if (!strcmp("not", parts[i])) {
            if (!on) {
                debug("    " T4LIT(!,warning) " Condition contains multiple negation: " T4LIT(%s,warning) "\n", ltrimmed_cond);
                result = false;
                goto free_mem; // breaking out of outermost loop
            }
            on = false;
            continue;
        }
        
        // we have found a table name
        
        if (reqcond == reqcond_NONE) {
            debug("    " T4LIT(!,warning) " Table " T4LIT(%s,table) " found, but no check (e.g. " T4LIT(hit) ") given in condition " T4LIT(%s,warning) "\n", parts[i], ltrimmed_cond);
            result = false;
            goto free_mem; // breaking out of outermost loop
        }
        
        result &= check_table_name(parts[i]);
        if (!result) {
            debug("    " T4LIT(!,warning) " Nonexistent table " T4LIT(%s,table) " given in condition " T4LIT(%s,warning) "\n", parts[i], ltrimmed_cond);
            result = false;
            goto free_mem; // breaking out of outermost loop
        }
        
        result &= check_table_requirement(parts[i], reqcond, on);
        if (!result) {
            debug("    " T4LIT(!,warning) " Requirement " T4LIT(%s%s) " on table " T4LIT(%s,table) " failed in condition " T4LIT(%s,warning) "\n",
            on ? "" : "not ", get_reqcond_txt(reqcond), parts[i], cond);
            result = false;
            goto free_mem; // breaking out of outermost loop
            } else {
            result = true;
            goto free_mem; // condition holds, breaking out of outermost loop
        }
        
        }
        
        debug("    " T4LIT(!,warning) " No table given in condition " T4LIT(%s,warning) "\n", cond);
        result = false;
        
        free_mem:
        free(parts[0]);
        return result;
    }
    
    
    bool check_controlflow_requirements(fake_cmd_t cmd) {
        bool result = true;
        const char* reqs = cmd.requirements[0];
        char* conds[MAX_PART_COUNT];
        int part_count = split(conds, reqs, ",");
        for (int i = 0; i < part_count; ++i) {
        result &= check_cond(conds[i]);
        }
        free(conds[0]);
        return result;
    }
    
    
#endif
