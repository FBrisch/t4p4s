// Autogenerated file (from src/hardware_indep/common.c.py: via hardware_indep/common.c.py), do not modify directly.
// Generator: T4P4S (https://github.com/P4ELTE/t4p4s/)

// SPDX-License-Identifier: Apache-2.0
// Copyright 2021 Eotvos Lorand University, Budapest, Hungary

#include "common.h"
#include "util_debug.h"

void do_assignment(header_instance_e dst_hdr, header_instance_e src_hdr, SHORT_STDPARAMS) {
    if (likely(is_header_valid(src_hdr, pd))) {
        if (unlikely(!is_header_valid(dst_hdr, pd))) {
            activate_hdr(dst_hdr, pd);
        }
        int copy_len = hdr_infos[src_hdr].byte_width + pd->headers[src_hdr].vw_size / 8;
        memcpy(pd->headers[dst_hdr].pointer, pd->headers[src_hdr].pointer, copy_len);
        dbg_bytes(pd->headers[dst_hdr].pointer, copy_len, "    " T4LIT(=,field) " Set " T4LIT(%s,header) "/" T4LIT(%dB) " = " T4LIT(%s,header) " = ",
        hdr_infos[dst_hdr].name, hdr_infos[src_hdr].byte_width, hdr_infos[src_hdr].name);
        } else {
        debug("    " T4LIT(=,status) " Set header " T4LIT(%s,header) "/" T4LIT(%dB) " = " T4LIT(invalid,status) " from " T4LIT(%s,header) "/" T4LIT(%dB) "\n",
        hdr_infos[dst_hdr].name, hdr_infos[dst_hdr].byte_width, hdr_infos[src_hdr].name, hdr_infos[src_hdr].byte_width);
        deactivate_hdr(dst_hdr, pd);
    }
}

void debug_validity_info_msg(bool is_valid, const uint8_t*const ptr, header_instance_e hdr, SHORT_STDPARAMS) {
    bool is_ok = is_header_valid(hdr, pd) == is_valid;
    const char* status_txt = is_valid ? T4LIT(valid,success) : T4LIT(invalid,status);
    if (is_ok) {
        debug("   :: Set header " T4LIT(%s,header) "/" T4LIT(%d) "+" T4LIT(%d) "B = %s\n",
        hdr_infos[hdr].name, pd->headers[hdr].size, pd->headers[hdr].vw_size/8, status_txt);
        } else {
        debug("   " T4LIT(!!,warning) " Trying to set header " T4LIT(%s,header) " to %s but it is already %s\n", hdr_infos[hdr].name, status_txt, status_txt);
    }
}

void set_hdr_valid(header_instance_e hdr, SHORT_STDPARAMS) {
    if (likely(!is_header_valid(hdr, pd))) {
        activate_hdr(hdr, pd);
        pd->is_deparse_reordering = true;
    }
    debug_validity_info_msg(true, pd->headers[hdr].pointer, hdr, SHORT_STDPARAMS_IN);
}

void set_hdr_invalid(header_instance_e hdr, SHORT_STDPARAMS) {
    if (likely(is_header_valid(hdr, pd))) {
        pd->headers[hdr].pointer = NULL;
        pd->is_deparse_reordering = true;
    }
    debug_validity_info_msg(false, pd->headers[hdr].pointer, hdr, SHORT_STDPARAMS_IN);
}

const char* error_value_names_error[7] = {
    "NoError",
    "PacketTooShort",
    "NoMatch",
    "StackOutOfBounds",
    "HeaderTooShort",
    "ParserTimeout",
    "ParserInvalidArgument",
};

const char* enum_value_names_CounterType[3] = {
    "packets",
    "bytes",
    "packets_and_bytes",
};

const char* enum_value_names_MeterType[2] = {
    "packets",
    "bytes",
};

const char* enum_value_names_HashAlgorithm[8] = {
    "crc32",
    "crc32_custom",
    "crc16",
    "crc16_custom",
    "random",
    "identity",
    "csum16",
    "xor16",
};

const char* enum_value_names_CloneType[2] = {
    "I2E",
    "E2E",
};

