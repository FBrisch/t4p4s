// Autogenerated file (from src/hardware_indep/tables.c.py: via hardware_indep/tables.c.py), do not modify directly.
// Generator: T4P4S (https://github.com/P4ELTE/t4p4s/)

#include "dataplane.h"
#include "actions.h"
#include "tables.h"
#include "stateful_memory.h"
#include "dpdk_lib.h"
#include "util_debug.h"

#ifdef T4P4S_DEBUG
    const char* all_table_short_names_sorted = "" T4LIT(ipv4_lpm,table) ", " T4LIT(nexthops,table);
    const int   all_table_short_names_count  = 2;
    const char* table_short_names_sorted     = "" T4LIT(ipv4_lpm,table) ", " T4LIT(nexthops,table);
    const int   table_short_names_count      = 2;
#endif

#define TABLE_CONFIG_ENTRY_DEF(tname,cname,sname,mt,hidden,keysize,size) (lookup_table_t) { \
    .name           = #tname, \
    .canonical_name = #cname, \
    .short_name     = #sname, \
    .id = TABLE_ ## tname, \
    .type = LOOKUP_ ## mt, \
    .default_val = NULL, \
    .is_hidden = hidden, \
    .entry = { \
        .entry_count = 0, \
        .key_size = keysize, \
        .action_size = sizeof(tname ## _action_t), \
        .state_size = 0, \
    }, \
    .min_size = 0, \
    .max_size = size == NO_TABLE_SIZE ? MAX_TABLE_SIZE : size, \
}

lookup_table_t table_config[NB_TABLES] = {
TABLE_CONFIG_ENTRY_DEF(ipv4_lpm_0,.ipv4_lpm,ipv4_lpm,lpm,false,4,1024),
TABLE_CONFIG_ENTRY_DEF(nexthops_0,.nexthops,nexthops,exact,false,4,512),
};

void setdefault_ipv4_lpm_0(actions_e action_id, bool show_info) {
    ENTRY(ipv4_lpm_0) default_entry = { .id = action_id };
    table_setdefault_promote(TABLE_ipv4_lpm_0, (ENTRYBASE*)&default_entry, show_info);
}
void setdefault_nexthops_0(actions_e action_id, bool show_info) {
    ENTRY(nexthops_0) default_entry = { .id = action_id };
    table_setdefault_promote(TABLE_nexthops_0, (ENTRYBASE*)&default_entry, show_info);
}
#define SOCKET0 0

extern struct socket_state state[NB_SOCKETS];

void init_table_default_actions() {
    struct socket_state socket0 = state[SOCKET0];
    int current_replica_ipv4_lpm_0 = socket0.active_replica[TABLE_ipv4_lpm_0];
    if (likely(socket0.tables[TABLE_ipv4_lpm_0][current_replica_ipv4_lpm_0]->default_val == NULL)) {
        setdefault_ipv4_lpm_0(action_NoAction_1, false);
    }
    int current_replica_nexthops_0 = socket0.active_replica[TABLE_nexthops_0];
    if (likely(socket0.tables[TABLE_nexthops_0][current_replica_nexthops_0]->default_val == NULL)) {
        setdefault_nexthops_0(action_NoAction_2, false);
    }
}

char summary[1024];

void print_const_entry_summary() {
    #ifdef TEST_CONST_ENTRIES_simple
        char* summary_ptr = summary;
        int count = 0;
        bool is_first = true;
        if (count > 0) {
            debug(" :::: Const entries on tables: %s\n", summary);
        }
        
    #endif
}

void init_table_const_entries() {
    // no const entries in table ipv4_lpm_0
    // no const entries in table nexthops_0
    print_const_entry_summary();
}

// ============================================================================
// Getters

extern char* action_names[];
extern char* action_canonical_names[];
extern char* action_short_names[];
