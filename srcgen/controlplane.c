// Autogenerated file (from src/hardware_indep/controlplane.c.py: via hardware_indep/controlplane.c.py), do not modify directly.
// Generator: T4P4S (https://github.com/P4ELTE/t4p4s/)

#include <unistd.h>

#include "dpdk_lib.h"
#include "dpdk_primitives.h" // TODO remove
#include "actions.h"
#include "tables.h"
#include "controlplane.h"

#ifdef T4P4S_P4RT
    #include "PI/proto/pi_server.h"
    #include "p4rt/device_mgr.h"
    extern device_mgr_t *dev_mgr_ptr;
#endif

extern void table_ipv4_lpm_0_key(packet_descriptor_t* pd, uint8_t* key); // defined in dataplane.c
extern void table_nexthops_0_key(packet_descriptor_t* pd, uint8_t* key); // defined in dataplane.c
typedef struct {
    uint32_t keyelem_0_KeyElement_ipv4_dstAddr;
} table_key_ipv4_lpm_0_t;

typedef struct {
    uint32_t keyelem_0_KeyElement_all_metadatas__routing_metadata_nhgroup0;
} table_key_nexthops_0_t;

// note: ipv4_lpm alias .ipv4_lpm alias ipv4_lpm_0, lpm, 4
uint8_t ipv4_lpm_0_setup_key(p4_field_match_lpm_t** field_matches, table_key_ipv4_lpm_0_t* key) {
    uint8_t prefix_length = 0;
    prefix_length += field_matches[0]->prefix_length;
uint8_t fld_keyelem_0_KeyElement_ipv4_dstAddr_0009 = *(uint8_t*)field_matches[0]->bitmap;
key->keyelem_0_KeyElement_ipv4_dstAddr = fld_keyelem_0_KeyElement_ipv4_dstAddr_0009;
prefix_length += 4;
    return prefix_length;
}

// note: nexthops alias .nexthops alias nexthops_0, exact, 4
void nexthops_0_setup_key(p4_field_match_exact_t** field_matches, table_key_nexthops_0_t* key) {
memcpy(&(key->keyelem_0_KeyElement_all_metadatas__routing_metadata_nhgroup0), field_matches[0]->bitmap, 4);
}

bool ipv4_lpm_0_setup_entry(ENTRY(ipv4_lpm_0)* entry, p4_action_parameter_t** action_params, const char* action_name) {
    if (strcmp(".set_nhop", action_name)==0) {
        entry->id = action_set_nhop;
        memcpy(&entry->params.set_nhop_params.nhgroup_1, action_params[0]->bitmap, 4);
        } else if (strcmp("._drop", action_name)==0) {
        entry->id = action__drop;
        } else if (strcmp(".NoAction", action_name)==0) {
        entry->id = action_NoAction_1;
        } else {
        debug(" " T4LIT(!!!! Table add entry,warning) " on table " T4LIT(ipv4_lpm,table) ": action name " T4LIT(mismatch,warning) ": " T4LIT(%s,action) ", expected one of (" T4LIT(.set_nhop,action) ", " T4LIT(._drop,action) ", " T4LIT(.NoAction,action) ").\n", action_name);
        return false;
    }
    return true;
}

bool nexthops_0_setup_entry(ENTRY(nexthops_0)* entry, p4_action_parameter_t** action_params, const char* action_name) {
    if (strcmp(".forward", action_name)==0) {
        entry->id = action_forward;
        memcpy(&entry->params.forward_params.dmac_val, action_params[0]->bitmap, 6);
        memcpy(&entry->params.forward_params.smac_val, action_params[1]->bitmap, 6);
        memcpy(&entry->params.forward_params.port, action_params[2]->bitmap, 2);
        } else if (strcmp("._drop", action_name)==0) {
        entry->id = action__drop_1;
        } else if (strcmp(".NoAction", action_name)==0) {
        entry->id = action_NoAction_2;
        } else {
        debug(" " T4LIT(!!!! Table add entry,warning) " on table " T4LIT(nexthops,table) ": action name " T4LIT(mismatch,warning) ": " T4LIT(%s,action) ", expected one of (" T4LIT(.forward,action) ", " T4LIT(._drop,action) ", " T4LIT(.NoAction,action) ").\n", action_name);
        return false;
    }
    return true;
}

void ipv4_lpm_0_add_table_entry(p4_ctrl_msg_t* ctrl_m) {
    ENTRY(ipv4_lpm_0) entry;
    bool success = ipv4_lpm_0_setup_entry(&entry, (p4_action_parameter_t**)ctrl_m->action_params, ctrl_m->action_name);
    if (unlikely(!success))    return;
    
    table_key_ipv4_lpm_0_t key;
    int prefix_length = ipv4_lpm_0_setup_key((p4_field_match_lpm_t**)ctrl_m->field_matches, &key);
    
    lpm_add_promote(TABLE_ipv4_lpm_0, (uint8_t*)&key, prefix_length,  (ENTRYBASE*)&entry, false, false || ctrl_is_initialized);
}

void nexthops_0_add_table_entry(p4_ctrl_msg_t* ctrl_m) {
    ENTRY(nexthops_0) entry;
    bool success = nexthops_0_setup_entry(&entry, (p4_action_parameter_t**)ctrl_m->action_params, ctrl_m->action_name);
    if (unlikely(!success))    return;
    
    table_key_nexthops_0_t key;
    nexthops_0_setup_key((p4_field_match_exact_t**)ctrl_m->field_matches, &key);
    
    exact_add_promote(TABLE_nexthops_0, (uint8_t*)&key,  (ENTRYBASE*)&entry, false, false || ctrl_is_initialized);
}

#ifdef T4P4S_DEBUG
    bool possible_tables_already_shown = false;
    #ifdef T4P4S_SHOW_HIDDEN_TABLES
        bool show_hidden_tables = true;
        #else
        bool show_hidden_tables = false;
    #endif
    
    void debug_show_possible_tables() {
        if (possible_tables_already_shown)   return;
        if (show_hidden_tables) {
            debug("   " T4LIT(!!,warning) " Possible table names: "T4LIT(.ipv4_lpm,table)", "T4LIT(.nexthops,table)"\n");
            } else {
            debug("   " T4LIT(!!,warning) " Possible table names: "T4LIT(.ipv4_lpm,table)", "T4LIT(.nexthops,table)" and " T4LIT(%d) " hidden tables\n", 0);
        }
        possible_tables_already_shown = true;
    }
    
#endif

void ctrl_add_table_entry(p4_ctrl_msg_t* ctrl_m) {
    if (strcmp(".ipv4_lpm", ctrl_m->table_name) == 0) {
        ipv4_lpm_0_add_table_entry(ctrl_m);
        return;
    }
    if (strcmp(".nexthops", ctrl_m->table_name) == 0) {
        nexthops_0_add_table_entry(ctrl_m);
        return;
    }
    debug(" " T4LIT(!!!! Table add entry,warning) ": " T4LIT(unknown table name,warning) " " T4LIT(%s,table) "\n", ctrl_m->table_name);
    #ifdef T4P4S_DEBUG
        debug_show_possible_tables();
    #endif
}

extern char* action_names[];

void ctrl_setdefault(p4_ctrl_msg_t* ctrl_m) {
    if (strcmp(".ipv4_lpm", ctrl_m->table_name) == 0) {
        ipv4_lpm_0_action_t default_entry;
        make_ipv4_lpm_0_set_default_table_entry(&default_entry, ctrl_m->action_name, (p4_action_parameter_t**)ctrl_m->action_params);
        table_setdefault_promote(TABLE_ipv4_lpm_0, (ENTRYBASE*)&default_entry, false);
        return;
    }
    if (strcmp(".nexthops", ctrl_m->table_name) == 0) {
        nexthops_0_action_t default_entry;
        make_nexthops_0_set_default_table_entry(&default_entry, ctrl_m->action_name, (p4_action_parameter_t**)ctrl_m->action_params);
        table_setdefault_promote(TABLE_nexthops_0, (ENTRYBASE*)&default_entry, false);
        return;
    }
    debug(" " T4LIT(!!!! Table set default,warning) ": " T4LIT(unknown table name,warning) " " T4LIT(%s,table) "\n", ctrl_m->table_name);
    #ifdef T4P4S_DEBUG
        debug_show_possible_tables();
    #endif
}

uint32_t* read_counter_value_by_name_packets(char* counter_name, int* size, bool is_bytes) {
    *size = -1;
    return 0;
}

uint32_t* read_counter_value_by_name_bytes(char* counter_name, int* size, bool is_bytes) {
    *size = -1;
    return 0;
}

uint32_t* read_counter_value_by_name(char* counter_name, int* size, bool is_bytes) {
    return is_bytes ? read_counter_value_by_name_bytes(counter_name, size, is_bytes) : read_counter_value_by_name_packets(counter_name, size, is_bytes);
}

extern struct socket_state state[NB_SOCKETS];

extern volatile bool ctrl_is_initialized;

void ctrl_initialized() {
    debug("   " T4LIT(::,incoming) " Control plane init " T4LIT(done,success) "\n");
    ctrl_is_initialized = true;
}

void recv_from_controller(p4_ctrl_msg_t* ctrl_m) {
    if (ctrl_m->type == P4T_ADD_TABLE_ENTRY) {
        ctrl_add_table_entry(ctrl_m);
        } else if (ctrl_m->type == P4T_SET_DEFAULT_ACTION) {
        ctrl_setdefault(ctrl_m);
        } else if (ctrl_m->type == P4T_CTRL_INITIALIZED) {
        ctrl_initialized();
        } else if (ctrl_m->type == P4T_READ_COUNTER) {
        //ctrl_m->xid = *read_counter_value_by_name(ctrl_m->table_name);
        //TODO:SEND BACK;
        } else {
        debug(" " T4LIT(!!!!) " Unknown message (type %d) arrived from the controller\n", ctrl_m->type);
    }
}

ctrl_plane_backend bg;

void print_table_summary() {
    #ifdef T4P4S_DEBUG
        for (int i = 0; i < NB_TABLES; i++) {
            lookup_table_t t = table_config[i];
            if (state[0].tables[t.id][0]->init_entry_count > 0)
            debug("    " T4LIT(:,incoming) " Table " T4LIT(%s,table) " got " T4LIT(%d) " entries from the control plane\n", state[0].tables[t.id][0]->short_name, state[0].tables[t.id][0]->init_entry_count);
        }
    #endif
}

void init_control_plane() {
    bg = create_backend(3, 1000, "localhost", T4P4S_CTL_PORT, recv_from_controller);
    launch_backend(bg);
    #ifdef T4P4S_P4RT
        dev_mgr_init_with_t4p4s(dev_mgr_ptr, recv_from_controller, read_counter_value_by_name, 1);
        PIGrpcServerRunAddrGnmi("0.0.0.0:50051", 0);
        //PIGrpcServerRun();
        #else
        print_table_summary();
    #endif
}

