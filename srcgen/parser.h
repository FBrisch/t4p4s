// Autogenerated file (from src/hardware_indep/parser.h.py: via hardware_indep/parser.h.py), do not modify directly.
// Generator: T4P4S (https://github.com/P4ELTE/t4p4s/)

#pragma once

#include <byteswap.h>
#include <stdbool.h>
#include "aliases.h"
#include "hdr_fld.h"
#include "common_enums.h"

#define to_bytes(bits) (((bits) + 7) / 8)

// TODO documentation
#define mod_top(n, bits) (((bits-(n%bits)) % bits))

// Produces a 32 bit int that has n bits on at the top end.
#define uint32_top_bits(n) (0xffffffff << mod_top(n, 32))

// the type has some optional values
#define MAYBE(type,...)    type

#define NO_VW_FIELD_PRESENT (-1)
#define NO_STACK_PRESENT    (-1)

typedef enum {
    NOT_MODIFIED,
    MODIFIED,
} parsed_field_attr_t;

typedef struct {
    uint8_t FLD(ethernet,dstAddr)[(48 + 7) / 8];
    uint8_t FLD(ethernet,srcAddr)[(48 + 7) / 8];
    uint16_t FLD(ethernet,etherType);
    uint8_t FLD(ipv4,versionIhl);
    uint8_t FLD(ipv4,diffserv);
    uint16_t FLD(ipv4,totalLen);
    uint16_t FLD(ipv4,identification);
    uint16_t FLD(ipv4,fragOffset);
    uint8_t FLD(ipv4,ttl);
    uint8_t FLD(ipv4,protocol);
    uint16_t FLD(ipv4,hdrChecksum);
    uint32_t FLD(ipv4,srcAddr);
    uint32_t FLD(ipv4,dstAddr);
    uint16_t FLD(arp,hardware_type);
    uint16_t FLD(arp,protocol_type);
    uint8_t FLD(arp,HLEN);
    uint8_t FLD(arp,PLEN);
    uint16_t FLD(arp,OPER);
    uint8_t FLD(arp,sender_ha)[(48 + 7) / 8];
    uint32_t FLD(arp,sender_ip);
    uint8_t FLD(arp,target_ha)[(48 + 7) / 8];
    uint32_t FLD(arp,target_ip);
    
    
    parsed_field_attr_t FLD_ATTR(ethernet,dstAddr);
    parsed_field_attr_t FLD_ATTR(ethernet,srcAddr);
    parsed_field_attr_t FLD_ATTR(ethernet,etherType);
    parsed_field_attr_t FLD_ATTR(ipv4,versionIhl);
    parsed_field_attr_t FLD_ATTR(ipv4,diffserv);
    parsed_field_attr_t FLD_ATTR(ipv4,totalLen);
    parsed_field_attr_t FLD_ATTR(ipv4,identification);
    parsed_field_attr_t FLD_ATTR(ipv4,fragOffset);
    parsed_field_attr_t FLD_ATTR(ipv4,ttl);
    parsed_field_attr_t FLD_ATTR(ipv4,protocol);
    parsed_field_attr_t FLD_ATTR(ipv4,hdrChecksum);
    parsed_field_attr_t FLD_ATTR(ipv4,srcAddr);
    parsed_field_attr_t FLD_ATTR(ipv4,dstAddr);
    parsed_field_attr_t FLD_ATTR(arp,hardware_type);
    parsed_field_attr_t FLD_ATTR(arp,protocol_type);
    parsed_field_attr_t FLD_ATTR(arp,HLEN);
    parsed_field_attr_t FLD_ATTR(arp,PLEN);
    parsed_field_attr_t FLD_ATTR(arp,OPER);
    parsed_field_attr_t FLD_ATTR(arp,sender_ha);
    parsed_field_attr_t FLD_ATTR(arp,sender_ip);
    parsed_field_attr_t FLD_ATTR(arp,target_ha);
    parsed_field_attr_t FLD_ATTR(arp,target_ip);
    
} parsed_fields_t;

// Header instance infos
// ---------------------

#define HEADER_COUNT 3
#define FIELD_COUNT 22
#define STACK_COUNT 1

extern const char*const field_names[FIELD_COUNT];
extern const char*const header_instance_names[HEADER_COUNT];

#define NONMETA_HDR_TOTAL_LENGTH (14+20+28)

typedef enum {
    HDR(ethernet),
    HDR(ipv4),
    HDR(arp),
} header_instance_e;

typedef enum {
    FLD(ethernet,dstAddr),
    FLD(ethernet,srcAddr),
    FLD(ethernet,etherType),
    FLD(ipv4,versionIhl),
    FLD(ipv4,diffserv),
    FLD(ipv4,totalLen),
    FLD(ipv4,identification),
    FLD(ipv4,fragOffset),
    FLD(ipv4,ttl),
    FLD(ipv4,protocol),
    FLD(ipv4,hdrChecksum),
    FLD(ipv4,srcAddr),
    FLD(ipv4,dstAddr),
    FLD(arp,hardware_type),
    FLD(arp,protocol_type),
    FLD(arp,HLEN),
    FLD(arp,PLEN),
    FLD(arp,OPER),
    FLD(arp,sender_ha),
    FLD(arp,sender_ip),
    FLD(arp,target_ha),
    FLD(arp,target_ip),
} field_instance_e;

typedef enum {
    STK(__dummy__),
} header_stack_e;

typedef struct {
    const int        idx;
    const int        stack_idx;
    const char*const name;
    
    const int        byte_width;
    const int        byte_offset;
    
    const bool       is_metadata;
    
    const field_instance_e first_fld;
    const field_instance_e last_fld;
    
    const MAYBE(field_instance_e, NO_VW_FIELD_PRESENT) var_width_field;
    const int var_width_size;
} hdr_info_t;

typedef struct {
    const int               size;
    const int               bit_offset;
    const int               byte_width;
    const int               byte_offset;
    const uint32_t          mask;
    const bool              is_metadata;
    const bool              is_vw;
    const field_instance_e  instance;
    const header_instance_e header_instance;
    const char*const        name;
    const char*const        short_name;
} fld_info_t;

typedef struct {
    const int               size;
    const int               fld_count;
    const header_instance_e start_hdr;
    const field_instance_e  start_fld;
} stk_info_t;

extern const hdr_info_t hdr_infos[HEADER_COUNT];
extern const fld_info_t fld_infos[FIELD_COUNT];
extern const stk_info_t stk_infos[STACK_COUNT];

// HW optimization related infos
// --------------------

#define OFFLOAD_CHECKSUM false

// Parser state local vars
// -----------------------

typedef struct {
    // no parser locals
} parser_state_t;

#define PARSED_AFTER_END_OF_PACKET INT_MIN
#define PARSED_OVER_STACK_SIZE     (INT_MIN+1)
#define HDR_PARSED_OK              0
